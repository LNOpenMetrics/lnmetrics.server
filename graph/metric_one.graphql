directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type StatusChannel {
     node_id: String! @goField(name: "NodeId")
     node_alias: String! @goField(name: "NodeAlias")
     color: String! @goField(name: "Color")
     capacity: Int! @goField(name: "Capacity")
     forwards: [PaymentInfo!]! @goField(name: "Forwards")
     up_times: [ChannelStatus!]! @goField(name: "UpTimes")
     online: Boolean! @goField(name: "Online")
     last_update: Int! @goField(name: "LastUpdate")
     public: Boolean! @goField(name: "Public")
     direction: String! @goField(name: "Direction")
}

type PaymentInfo {
     direction: String! @goField(name: "Direction")
     status: String! @goField(name: "Status")
     failure_reason: String @goField(name: "FailureReason")
     failure_code: Int @goField(name: "FailureCode")
}

type ChannelStatus {
     timestamp: Int! @goField(name: "Timestamp")
     status: String! @goField(name: "Status")
}

# Information about the node implementation
type NodeImpInfo {
  implementation: String! @goField(name: "Implementation")
  version: String! @goField(name: "Version")
}

type MetricOne {
  metric_name: String! @goField(name: "Name")
  node_id: String! @goField(name: "NodeID")
  color: String! @goField(name: "Color")
  node_alias: String! @goField(name: "NodeAlias")
  # Network must be not null but in the server we miss
  # some migration policy, so for the momenet we accept null value
  network: String @goField(name: "Network")
  os_info: OSInfo! @goField(name: "OSInfo")
  # Null for the same reason of Network
  node_info: NodeImpInfo @goField(name: "NodeInfo")
  address: [NodeAddress!]! @goField(name: "Address")
  timezone: String! @goField(name: "Timezone")
  up_time: [Status!]! @goField(name: "UpTime")
  channels_info: [StatusChannel] @goField(name: "ChannelsInfo")
  # Same reason of the Network.
  version: Int @goField(name: "Version")
}

type NodeInfo {
     node_id: String! @goField(name: "NodeId")
     metric_one: MetricOne! @goField(name: "MetricOne")
}

type OSInfo {
     os: String! @goField(name: "Os")
     version: String! @goField(name: "Version")
     architecture: String! @goField(name: "Architecture")
}

type Status {
     event: String! @goField(name: "Event")
     channels: ChannelsSummary! @goField(name: "Channels")
     forwards: PaymentsSummary! @goField(name: "Forwards")
     timestamp: Int! @goField(name: "Timestamp")
}

type ChannelsSummary {
     tot_channels: Int! @goField(name: "TotChannels")
     summary: [ChannelSummary!]! @goField(name: "Summary")
}

type ChannelSummary {
     node_id: String! @goField(name: "NodeId")
     alias: String! @goField(name: "alias")
     color: String! @goField(name: "color")
     channel_id: String! @goField(name: "channelId")
     state: String! @goField(name: "state")
}

type PaymentsSummary {
     completed: Int! @goField(name: "Completed")
     failed: Int!  @goField(name: "Failed")
}

# Type that are used inside the query side
type NodeMetadata {
  node_id: String! @goField(name: "NodeId")
  alias: String! @goField(name: "Alias")
  color: String! @goField(name: "Color")
  address: [NodeAddress!]! @goField(name: "Address")
  os_info: OSInfo! @goField(name: "OsInfo")
  node_info: NodeInfo! @goField(name: "NodeInfo")
}

# Node address to be reach
type NodeAddress {
  type: String! @goField(name: "Type")
  host: String! @goField(name: "Host")
  port: Int! @goField(name: "Port")
}

input NodeMetrics {
     node_id: String! @goField(name: "NodeID")
     payload_metric_one: String! @goField(name: "PayloadMetricOne")
}

# Query definition
type Query {
  # Get the list of nodes that are contributing in metric collection
  getNodes(network: String!): [NodeMetadata!]!
  # Get the node metadata if exist on the server
  getNode(network: String!, node_id: String!): NodeMetadata!
  # Get Metric One of the node id in a period [start, end], if the end and start are -1
  # the query return all the data collected from the entire period of metrics collection.
  getMetricOne(node_id: String!, start_period: Int!, end_period: Int!): MetricOne!
}

type Mutation {
  addNodeMetrics(input: NodeMetrics!): MetricOne!
  # Mutation query that it is called from client side when it is back
  # or it is the first time that it is on online on the network
  # in case we know already this metrics, and the client have a clean db, we
  # will return the full Metric One
  initMetricOne(node_id: String!, payload: String!, signature: String!): MetricOne!
  # Mutation query that it is called from a client side when the time to
  # Update the metrics came.
  updateMetricOne(node_id: String!, payload: String!, signature: String!): Boolean!
}
